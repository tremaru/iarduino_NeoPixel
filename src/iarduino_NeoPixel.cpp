#include "iarduino_NeoPixel.h"																								//
																															//
		iarduino_NeoPixel::iarduino_NeoPixel(uint8_t i, uint16_t j){														//
			pinOutput			=	i;																						//	Сохраняем номер выхода, к которому подключены светодиоды
			lenLED				=	j;																						//	Сохраняем количество подключённых светодиодов
			#if defined(ESP32)																								//
			portOutput			=	(uint32_t*) portOutputRegister(digitalPinToPort(pinOutput));							//	Получаем указатель на адрес регистра выходных значений порта на котором присутствует выход pinOutput. Функция digitalPinToPort возвращает номер, соответствующий порту на котором находится вывод pinOutput, а функция portOutputRegister возвращает указатель на адрес регистра выходных значений этого порта
			#else																											//
			portOutput			=	(uint16_t*) portOutputRegister(digitalPinToPort(pinOutput));							//	Получаем указатель на адрес регистра выходных значений порта на котором присутствует выход pinOutput. Функция digitalPinToPort возвращает номер, соответствующий порту на котором находится вывод pinOutput, а функция portOutputRegister возвращает указатель на адрес регистра выходных значений этого порта
			#endif																											//
			pinMask				=	digitalPinToBitMask(pinOutput);															//	Получаем маску вывода, это байт в котором установлен только один бит. Порядковый номер этого бита, соответствует номеру вывода pinOutput (от 0 до 7) на порту portOutput
}																															//
																															//
bool	iarduino_NeoPixel::begin(void){																						//
		    pinMode					(pinOutput, OUTPUT);																	//	Конфигурируем вывод pinOutput как выход
			digitalWrite			(pinOutput, LOW);																		//	Устанавливаем на выходе pinOutput уровень логического «0»
			lenRGB				=	lenLED*3;																				//	Получаем размер массива цветов светодиодов
			if((arrRGB			=	(uint8_t *) malloc(lenRGB))){															//	Выделяем область памяти, размером lenRGB байт, под массив для хранения цветов светодиодов, адрес первой ячейки памяти массива передаём указателю arrRGB
				memset				(arrRGB, 0, lenRGB);																	//	Сбрасываем в 0 все байты массива по указателю arrRGB
			}else					{lenRGB=0; return false;}																//	Если память выделить не удалось, то указываем размер массива равным 0 байт и возвращаем false
			return true;																									//	Возвращаем флаг успешной инициализации
}																															//
																															//
void	iarduino_NeoPixel::setColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b, uint8_t j){								//
			if(lenRGB){																										//	Если была успешно вызвана функция begin, то ...
				if(j<127){ r=map(j,  0,126,0,  r); g=map(j,  0,126,0,  g); b=map(j,  0,126,0,  b);}else						//	Если требуется затемнить цвет, то ...
				if(j>127){ r=map(j,128,255,r,255); g=map(j,128,255,g,255); b=map(j,128,255,b,255);}							//	Если требуется осветлить цвет, то ...
				if(n == NeoPixelAll){																						//	Если требуется установить цвета для всех светодиодов, то ...
					for(uint16_t i=0; i<lenLED; i++){																		//	Проходим по всем светодиодам
						arrRGB[i*3+0] =	g;																					//	Устанавливаем цвет Green	(зелёный)
						arrRGB[i*3+1] =	r;																					//	Устанавливаем цвет Red		(красный)
						arrRGB[i*3+2] =	b;																					//	Устанавливаем цвет Blue		(синий)
					}																										//
				}else if(lenLED > n){																						//	Если требуется установть цвет только одному светодиоду и количество светодиодов больше чем номер нужного светодиода, то ...
						arrRGB[n*3+0] =	g;																					//	Устанавливаем цвет Green	(зелёный)
						arrRGB[n*3+1] =	r;																					//	Устанавливаем цвет Red		(красный)
						arrRGB[n*3+2] =	b;																					//	Устанавливаем цвет Blue		(синий)
				}																											//
			}																												//
}																															//
																															//
void	iarduino_NeoPixel::write(){																							//
			uint8_t* arr  = arrRGB;																							//	Указатель на массив с данными для передачи.
			uint8_t  byte = 0;																								//	Значение очередного передаваемого байта.
			uint8_t  bit  = 8;																								//	Количество ещё не переданных бит.
			uint16_t len  = lenRGB+1;																						//	Количество передаваемых байтов.
			bitLow	      = *portOutput & ~pinMask;																			//	Значение, запись которого в регистр по адресу portOutput, приведёт к установке логического «0» на вывхде pinOutput, не затрагивая уровни других выводов.
			bitHigh	      = *portOutput |  pinMask;																			//	Значение, запись которого в регистр по адресу portOutput, приведёт к установке логической  «1» на вывхде pinOutput, не затрагивая уровни других выводов.
																															//
			if(lenRGB){																										//	Передаём данные, если количество светодиодов больше 0 и была успешно вызвана функция begin
				//	============================================== AVR ===================================================	//
				//	---------------------------------------------- AVR <8 МГц --------------------------------------------	//
				#if defined(__AVR__) && (F_CPU<6000000UL)																	//
					#error Библиотека <iarduino_NeoPixel> не поддерживает микроконтроллеры AVR с частотой ниже 8 МГц.		//
				//	---------------------------------------------- AVR 8 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=6000000UL) && (F_CPU<10000000UL)											//
				//	1 м.т. = 1/8МГц = 125нс																					//
				//	Время передачи одного бита = 10 м.т. * 125 нс = 1250 нс.												//
				//	 ___																									//
				//	|375|875нс(7мт)																							//
				//	|3мт|________  передача логического «0»																	//
				//	 ________																								//
				//	| 875 нс |375н																							//
				//	|(7 м.т.)|___  передача логической  «1»																	//
				//																											//
				//	 HHH XXXX LLL  уровни машинных тактов (м.т.)															//
				//	 123 4567 890																							//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=03/04, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=05/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=06/05, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=08/07, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=09/08, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=10/09, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=12/11, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				//	--------------------------------------------- AVR 12 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=10000000UL) && (F_CPU<14000000UL)											//
				//	1 м.т. = 1/12МГц = 83,(3)нс																				//
				//	Время передачи одного бита = 15 м.т. * 83,(3) нс = 1250 нс.												//
				//	 ____																									//
				//	|333н| 917нс (11мт)																						//
				//	|4мт |____________  передача логического «0»															//
				//	 ____________																							//
				//	|    917 нс  |333н																						//
				//	|  (11 м.т.) |____  передача логической  «1»															//
				//																											//
				//	 HHHH XXXXXXX LLLL   уровни машинных тактов (м.т.)														//
				//	 1234 5678901 2345																						//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"nop							\n\t"	//	1/1 м.т., T=03/03, out=1/1								//	Пропускаем один машинный такт (м.т.)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=04/05, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=06/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=07/06, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"nop							\n\t"	//	1/1 м.т., T=08/07, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=09/08, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=10/09, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=11/10, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=13/12, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=14/13, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=15/14, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=16/15, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				//	--------------------------------------------- AVR 16 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=14000000UL) && (F_CPU<20000000UL)											//
				//	1 м.т. = 1/16МГц = 62,5нс																				//
				//	Время передачи одного бита = 20 м.т. * 62,5 нс = 1250 нс.												//
				//	 ______																									//
				//	| 375нс|  875нс (14мт)																					//
				//	| (6мт)|_______________  передача логического «0»														//
				//	 _______________																						//
				//	|    875 нс     | 375нс																					//
				//	|  (14 м.т.)    |______  передача логической  «1»														//
				//																											//
				//	 HHHHHH XXXXXXXX LLLLLL  уровни машинных тактов															//
				//	 123456 78901234 567890																					//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"nop							\n\t"	//	1/1 м.т., T=03/03, out=1/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=04/04, out=1/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=05/05, out=1/1								//	Пропускаем один машинный такт (м.т.)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=06/07, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=08/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=09/08, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"nop							\n\t"	//	1/1 м.т., T=10/09, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=11/10, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=12/11, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=13/12, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=14/13, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=15/14, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=17/16, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=18/17, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=19/18, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=21/20, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				//	--------------------------------------------- AVR 24 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=20000000UL) && (F_CPU<28000000UL)											//
				//	1 м.т. = 1/24МГц = 61,(6)нс																				//
				//	Время передачи одного бита = 30 м.т. * 61,(6) нс = 1250 нс.												//
				//	 _________																								//
				//	|  375нс  |     875нс (24мт)																			//
				//	|  (9мт)  |______________________  передача логического «0»												//
				//	 ______________________																					//
				//	|        875 нс        |   375нс																		//
				//	|       (21 м.т.)      |_________  передача логической  «1»												//
				//																											//
				//	 HHHHHHHHH XXXXXXXXXXXX LLLLLLLLL  уровни машинных тактов												//
				//	 123456789 012345678901 234567890																		//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=04/04, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=06/06, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=08/08, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=09/10, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=11/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=12/11, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=14/13, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=16/15, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=18/17, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=20/19, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=22/21, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=24/23, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=26/25, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=27/26, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=28/27, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=30/29, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				//	--------------------------------------------- AVR 32 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=28000000UL) && (F_CPU<36000000UL)											//
				//	1 м.т. = 1/32МГц = 31,25нс																				//
				//	Время передачи одного бита = 40 м.т. * 31,25 нс = 1250 нс.												//
				//	 ____________																							//
				//	|   375 нс   |       875 нс (28 м.т.)																	//
				//	| (12 м.т.)  |_____________________________  передача логического «0»									//
				//	 _____________________________																			//
				//	|          875 нс             |   375 нс																//
				//	|        (28 м.т.)            |____________  передача логической  «1»									//
				//																											//
				//	 HHHHHHHHHHHH XXXXXXXXXXXXXXXX LLLLLLLLLLLL  уровни машинных тактов										//
				//	 000000000111 1111111222222222 233333333334																//
				//	 123456789012 3456789012345678 901234567890																//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=04/04, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=06/06, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=08/08, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=10/10, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=11/11, out=1/1								//	Пропускаем один машинный такт (м.т.)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=12/13, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=14/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=15/14, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=17/16, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=19/18, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=21/20, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=23/22, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=25/24, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=27/26, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=28/27, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=30/29, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=32/31, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=34/33, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=36/35, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=37/36, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=38/37, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=40/39, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				//	--------------------------------------------- AVR 40 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=36000000UL) && (F_CPU<44000000UL)											//
				//	1 м.т. = 1/40МГц = 25нс																					//
				//	Время передачи одного бита = 50 м.т. * 25 нс = 1250 нс.													//
				//	 _______________																						//
				//	|    375 нс     |           875 нс (35 м.т.)															//
				//	|   (15 м.т.)   |____________________________________  передача логического «0»							//
				//	 ____________________________________																	//
				//	|                  875 нс            |    375 нс														//
				//	|                 (35 м.т.)          |_______________  передача логической  «1»							//
				//																											//
				//	 HHHHHHHHHHHHHHH XXXXXXXXXXXXXXXXXXXX LLLLLLLLLLLLLLL  уровни машинных тактов							//
				//	 000000000111111 11112222222222333333 333344444444445													//
				//	 123456789012345 67890123456789012345 678901234567890													//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=04/04, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=06/06, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=08/08, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=10/10, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=12/12, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=14/14, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=15/16, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=17/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=18/17, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=20/19, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=22/21, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=24/23, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=26/25, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=28/37, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=30/29, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=32/31, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=34/33, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=36/35, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=38/37, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=40/39, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=42/41, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=44/43, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=46/46, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=47/46, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=48/47, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=50/49, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				//	--------------------------------------------- AVR 48 МГц ---------------------------------------------	//
				#elif defined(__AVR__) && (F_CPU>=44000000UL) && (F_CPU<52000000UL)											//
				//	1 м.т. = 1/48МГц = 20,8(3)нс																			//
				//	Время передачи одного бита = 60 м.т. * 20,8(3) нс = 1250 нс.											//
				//	 __________________																						//
				//	|      375 нс      |               875 нс (42 м.т.)														//
				//	|     (18 м.т.)    |___________________________________________  передача логического «0»				//
				//	 ___________________________________________															//
				//	|                  875 нс                   | 375 нс (18 м.т.)											//
				//	|                 (42 м.т.)                 |__________________  передача логической  «1»				//
				//																											//
				//	 HHHHHHHHHHHHHHHHHH XXXXXXXXXXXXXXXXXXXXXXXX LLLLLLLLLLLLLLLLLL  уровни машинных тактов					//
				//	 000000000111111111 122222222223333333333444 444444455555555556											//
				//	 123456789012345678 901234567890123456789012 345678901234567890											//
																															//
					noInterrupts();																							//	Запрещаем исполнение прерываний во время вывода данных
																															//
					asm volatile(																							//
					//	Получение очередного байта:																			//
						"getbyte:						\n\t"	//															//	Метака getbyte (получение очередного байта для передачи).
						"ldi	%[bit]	,	8			\n\t"	//	1 м.т.	, T=01				bit = 8						//	Указываем что в передаваемом байте есть 8 не переданных битов
						"ld		%[byte]	,	%a[arr]+	\n\t"	//	2 м.т.	, T=03				byte = *arr++				//	Получаем 1 байт для передачи, копируя его из СОЗУ в регистр byte. Адрес ячейки СОЗУ берётся из указателя arr, значение которого мы увеличиваем после получения байта
						"sbiw	%[len]	,	1			\n\t"	//	2 м.т.	, T=05				len--						//	Уменьшаем значение регистра len (счётчик количества переданных байт) на 1
						"brne	sendbyte				\n\t"	//	2 м.т.	, T=07				if(len>0){goto sendbyte}	//	Если полученный байт не за пределами счетчика len, то переходим к блоку sendbyte для передачи этого байта
						"rjmp	exitsend				\n\t"	//	2 м.т.	,					goto exitsend				//	Выходим из Ассемблерной вставки
					//	Побитная передача очередного байта:																	//
						"sendbyte:						\n\t"	//"0"/"1"      "0"/"1"   "0"/"1"							//	Метка sendbyte (передача очередного бита).
						"st		%a[port],	%[high]		\n\t"	//	2/2 м.т., T=02/02, out=1/1	port = high					//	Устанавливаем на выводе pinOutput уровень логической «1» (записывая в порт port значение регистра high)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=04/04, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=06/06, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=08/08, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=10/10, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=12/12, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=14/14, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=16/16, out=1/1								//	Пропускаем два машинных такта (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=17/17, out=1/1								//	Пропускаем один машинный такт (м.т.)
						"sbrs	%[byte]	,	7			\n\t"	//	1/2 м.т., T=18/19, out=1/1	if(byte & 1<<7){jump}		//	Если установлен 7 бит в регистре byte, то следующая строка пропускается. Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=20/--, out=0/1	port = high					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rol	%[byte]					\n\t"	//	1/1 м.т., T=21/20, out=0/1	byte <<= 1					//	Сдвигаем влево все биты находящиеся в byte, (т.к. при передаче бита мы сверяемся со значением старшего бита)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=23/22, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=25/24, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=27/26, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=29/28, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=31/30, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=33/32, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=35/34, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=37/36, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=39/38, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=41/40, out=0/1								//	Пропускаем два машинных такта (м.т.)
						"nop							\n\t"	//	1/1 м.т., T=42/41, out=0/1								//	Пропускаем один машинный такт (м.т.)
						"st		%a[port],	%[low]		\n\t"	//	2/2 м.т., T=44/43, out=0/0	port = low					//	Устанавливаем на выводе pinOutput уровень логического «0» (записывая в порт port значение регистра low)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=46/45, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=48/47, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=50/49, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=52/51, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=54/53, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"rjmp	.+0						\n\t"	//	2/2 м.т., T=56/66, out=0/0								//	Пропускаем два машинных такта (м.т.)
						"dec	%[bit]					\n\t"	//	1/1 м.т., T=57/56, out=0/0	bit--						//	Уменьшаем значение регистра bit (счетчик не переданных битов байта) на 1
						"breq	getbyte					\n\t"	//	*/* м.т., T=58/57, out=0/0	if(bit==0){goto getbyte}	//	Если значение bit равно 0 (все биты переданы), то переходим к метке getbyte (для получения следующего байта). Если условие соблюдается, то команда выполняется за 2 м.т. , иначе за 1 м.т.
						"rjmp	sendbyte				\n\t"	//	2/2 м.т., T=60/59, out=0/0	goto sendbyte				//	Переходим к передачи следующего бита текущего байта
						"exitsend:						\n"		//	Метка выхода по ссылке rjmp exitsend					//	Метка выхода из Ассемблерной вставки
						://	Список выходных параметров:																		//
						[port]		"+e"	(portOutput),		//	+e	один из двухбайтных регистров указателей x,y,z		//	Адрес порта для передачи данных
						[byte]		"+r"	(byte),				//	+r	любой однобайтный регистр от r0 до r31				//	Передаваемый байт данных
						[bit]		"+r"	(bit)				//	+r	любой однобайтный регистр от r0 до r31				//	Количество еще не переданных бит из byte
						://	Список входных параметров:																		//
						[low]		"r"		(bitLow),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установился  логический «0»
						[high]		"r"		(bitHigh),			//	r	любой однобайтный регистр от r0 до r31				//	Значение которое требуется записать в порт, чтоб на выводе pinOutput установилась логическая «1»
						[arr]		"e"		(arrRGB),			//	e	один из двухбайтных регистров указателей x,y,z		//	Адрес первой ячейки блока памяти в котором находится массив данных
						[len]		"w"		(len)				//	w	один из верхних 2байтных рег-ов r24,r26,r28,r30		//	Счетчик количества переданных байтов
					);																										//
					interrupts();																							//	Возобновляем исполнение прерываний (если таковые были)
				#else // Еnd AVR <=48МГц																					//
				//	====================================== AVR >48 МГц, ARM, ESP ... =====================================	//
					//	-------------------------------------------- <16 МГц ---------------------------------------------	//
					#if(F_CPU<14000000UL)																					//
						#error Библиотека <iarduino_NeoPixel> не поддерживает микроконтроллеры с частотой ниже 16 МГц.		//
					//	--------------------------------------------- 16 МГц ---------------------------------------------	//
					#elif(F_CPU>=14000000UL) && (F_CPU<20000000UL)															//
					//	1 м.т. = 1/16МГц = 62,5нс																			//
					//	Время передачи одного бита = 20 м.т. * 62,5 нс = 1250 нс.											//
					//	 ______																								//
					//	| 375нс|  875нс (14мт)																				//
					//	| (6мт)|_______________  передача логического «0»													//
					//	 _______________																					//
					//	|    875 нс     | 375нс																				//
					//	|  (14 м.т.)    |______  передача логической  «1»													//
					//																										//
					//	 HHHHHH XXXXXXXX LLLLLL  уровни машинных тактов														//
					//	 123456 78901234 567890																				//
					//	 __________________ ________________________ __________________										//
					//	|       6 м.т.     |          8 м.т.        |       6 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-7м.т.)_____|__(+2м.т.)_____(-5м.т.)_|______(-9м.т.)____| такты использованные в C++			//
						#define NeoPixel_FirstHIGH	""																		//	6м.т. - 7м.т. = 0м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;"						//	8м.т. + 2м.т. = 10м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop;"														//	8м.т. - 5м.т. = 3м.т.
						#define NeoPixel_LastLOW	""																		//	6м.т. - 9м.т. = 0м.т.
					//	--------------------------------------------- 24 МГц ---------------------------------------------	//
					#elif(F_CPU>=20000000UL) && (F_CPU<28000000UL)															//
					//	1 м.т. = 1/24МГц = 41,(6)нс																			//
					//	Время передачи одного бита = 30 м.т. * 41,(6) нс = 1250 нс.											//
					//	 ____________																						//
					//	|   375 нс   |       875 нс (21 м.т.)																//
					//	|  (9 м.т.)  |_____________________________  передача логического «0»								//
					//	 _____________________________																		//
					//	|          875 нс             |   375 нс															//
					//	|        (21 м.т.)            |____________  передача логической  «1»								//
					//	 __________________ ________________________ __________________										//
					//	|      9 м.т.      |         12 м.т.        |       9 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-7м.т.)_____|__(+2м.т.)_____(-5м.т.)_|______(-9м.т.)____| такты использованные в C++			//
						#define NeoPixel_FirstHIGH	"nop; nop;"																//	9м.т. - 7м.т. = 2м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" //	12м.т. + 2м.т. = 14м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop;"									//	12м.т. - 5м.т. = 7м.т.
						#define NeoPixel_LastLOW	""																		//	9м.т. - 9м.т. = 0м.т.
					//	--------------------------------------------- 32 МГц ---------------------------------------------	//
					#elif(F_CPU>=28000000UL) && (F_CPU<36000000UL)															//
					//	1 м.т. = 1/32МГц = 31,25нс																			//
					//	Время передачи одного бита = 40 м.т. * 31,25 нс = 1250 нс.											//
					//	 ____________																						//
					//	|   375 нс   |       875 нс (28 м.т.)																//
					//	| (12 м.т.)  |_____________________________  передача логического «0»								//
					//	 _____________________________																		//
					//	|          875 нс             |   375 нс															//
					//	|        (28 м.т.)            |____________  передача логической  «1»								//
					//	 __________________ ________________________ __________________										//
					//	|      12 м.т.     |         16 м.т.        |      12 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-7м.т.)_____|__(+2м.т.)_____(-5м.т.)_|______(-9м.т.)____| такты использованные в C++			//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop;"												//	12м.т. - 7м.т. = 5м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 16м.т. + 2м.т. = 18м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;"				//	16м.т. - 5м.т. = 11м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop;"														//	12м.т. - 9м.т. = 3м.т.
					//	--------------------------------------------- 40 МГц ---------------------------------------------	//
					#elif(F_CPU>=36000000UL) && (F_CPU<44000000UL)															//
					//	1 м.т. = 1/40МГц = 25нс																				//
					//	Время передачи одного бита = 50 м.т. * 25 нс = 1250 нс.												//
					//	 ____________																						//
					//	|   375 нс   |       875 нс (35 м.т.)																//
					//	| (15 м.т.)  |_____________________________  передача логического «0»								//
					//	 _____________________________																		//
					//	|          875 нс             |   375 нс															//
					//	|        (35 м.т.)            |____________  передача логической  «1»								//
					//	 __________________ ________________________ __________________										//
					//	|      15 м.т.     |         20 м.т.        |      15 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-7м.т.)_____|__(+2м.т.)_____(-5м.т.)_|______(-9м.т.)____| такты использованные в C++			//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop;"								//	15м.т. - 7м.т. = 8м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 20м.т. + 2м.т. = 22м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 20м.т. - 5м.т. = 15м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop;"											//	15м.т. - 9м.т. = 6м.т.
					//	--------------------------------------------- 48 МГц ---------------------------------------------	//
					#elif(F_CPU>=44000000UL) && (F_CPU<56000000UL)															//
					//	1 м.т. = 1/48МГц = 20,8(3)нс																		//
					//	Время передачи одного бита = 60 м.т. * 20,8(3) нс = 1250 нс.										//
					//	 __________________																					//
					//	|      375 нс      |               875 нс (42 м.т.)													//
					//	|     (18 м.т.)    |___________________________________________  передача логического «0»			//
					//	 ___________________________________________														//
					//	|                  875 нс                   | 375 нс (18 м.т.)										//
					//	|                 (42 м.т.)                 |__________________  передача логической  «1»			//
					//	 __________________ ________________________ __________________										//
					//	|      18 м.т.     |         24 м.т.        |      18 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-7м.т.)_____|__(+2м.т.)_____(-5м.т.)_|______(-9м.т.)____| такты уже использованные в C++		//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;"				//	18м.т. - 7м.т. = 11м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 24м.т. + 2м.т. = 26м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 24м.т. - 5м.т. = 19м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop;"							//	18м.т. - 9м.т. = 9м.т.
					//	-------------------------------------------- 62,5 МГц --------------------------------------------	//
					#elif(F_CPU>=56000000UL) && (F_CPU<70000000UL)															//
					//	1 м.т. = 1/62,5МГц = 16нс																			//
					//	Время передачи одного бита = 78 м.т. * 16 нс = 1250 нс.												//
					//	 __________________																					//
					//	|      375 нс      |               875 нс (55 м.т.)													//
					//	|     (23 м.т.)    |___________________________________________  передача логического «0»			//
					//	 ___________________________________________														//
					//	|                  875 нс                   | 375 нс (23 м.т.)										//
					//	|                 (55 м.т.)                 |__________________  передача логической  «1»			//
					//	 __________________ ________________________ __________________										//
					//	|      23 м.т.     |         32 м.т.        |      23 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-8м.т.)_____|__(+2м.т.)_____(-5м.т.)_|_____(-10м.т.)____| такты уже использованные в C++		//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop" // 23м.т. - 8м.т. = 15м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 32м.т. + 2м.т. = 34м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 32м.т. - 5м.т. = 27м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 23м.т. - 10м.т. = 13м.т.
					//	--------------------------------------------- 80 МГц ---------------------------------------------	//
					#elif(F_CPU>=70000000UL) && (F_CPU<100000000UL)															//
					//	1 м.т. = 1/80МГц = 12,5нс																			//
					//	Время передачи одного бита = 100 м.т. * 12,5 нс = 1250 нс.											//
					//	 __________________																					//
					//	|      375 нс      |               875 нс (70 м.т.)													//
					//	|     (30 м.т.)    |___________________________________________  передача логического «0»			//
					//	 ___________________________________________														//
					//	|                  875 нс                   | 375 нс (30 м.т.)										//
					//	|                 (70 м.т.)                 |__________________  передача логической  «1»			//
					//	 __________________ ________________________ __________________										//
					//	|      30 м.т.     |         40 м.т.        |      30 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-9м.т.)_____|__(+3м.т.)_____(-4м.т.)_|_____(-11м.т.)____| такты уже использованные в C++		//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 30м.т. - 9м.т. = 21м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 40м.т. + 3м.т. = 43м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 40м.т. - 4м.т. = 36м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 30м.т. - 11м.т. = 19м.т.
					//	-------------------------------------------- 120 МГц ---------------------------------------------	//
					#elif(F_CPU>=100000000UL) && (F_CPU<140000000UL)														//
					//	1 м.т. = 1/120МГц = 8,(3)нс																			//
					//	Время передачи одного бита = 150 м.т. * 8,(3) нс = 1250 нс.											//
					//	 __________________																					//
					//	|      375 нс      |              875 нс (105 м.т.)													//
					//	|     (45 м.т.)    |___________________________________________  передача логического «0»			//
					//	 ___________________________________________														//
					//	|                  875 нс                   | 375 нс (45 м.т.)										//
					//	|                (105 м.т.)                 |__________________  передача логической  «1»			//
					//	 __________________ ________________________ __________________										//
					//	|      45 м.т.     |         60 м.т.        |      45 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-9м.т.)_____|__(+2м.т.)____(-5м.т.)__|_____(-10м.т.)____| такты уже использованные в C++		//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 45м.т. - 9м.т. = 36м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 60м.т. + 2м.т. = 62м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 60м.т. - 5м.т. = 55м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 45м.т. - 10м.т. = 35м.т.
					//	-------------------------------------------- 160 МГц ---------------------------------------------	//
					#elif(F_CPU>=140000000UL) && (F_CPU<200000000UL)														//
					//	1 м.т. = 1/160МГц = 6,25нс																			//
					//	Время передачи одного бита = 200 м.т. * 6,25 нс = 1250 нс.											//
					//	 __________________																					//
					//	|      375 нс      |              875 нс (140 м.т.)													//
					//	|     (60 м.т.)    |___________________________________________  передача логического «0»			//
					//	 ___________________________________________														//
					//	|                  875 нс                   | 375 нс (60 м.т.)										//
					//	|                (140 м.т.)                 |__________________  передача логической  «1»			//
					//	 __________________ ________________________ __________________										//
					//	|      60 м.т.     |         80 м.т.        |      60 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-8м.т.)_____|__(+2м.т.)____(-6м.т.)__|_____(-10м.т.)____| такты уже использованные в C++		//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 60м.т. - 8м.т. = 52м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 80м.т. + 2м.т. = 82м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 80м.т. - 6м.т. = 74м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 60м.т. - 10м.т. = 50м.т.
					//	-------------------------------------------- 240 МГц ---------------------------------------------	//
					#elif(F_CPU>=200000000UL) && (F_CPU<280000000UL)														//
					//	1 м.т. = 1/240МГц = 4,1(6)нс																		//
					//	Время передачи одного бита = 300 м.т. * 4,1(6) нс = 1250 нс.										//
					//	 __________________																					//
					//	|      375 нс      |              875 нс (210 м.т.)													//
					//	|     (90 м.т.)    |___________________________________________  передача логического «0»			//
					//	 ___________________________________________														//
					//	|                  875 нс                   | 375 нс (90 м.т.)										//
					//	|                (210 м.т.)                 |__________________  передача логической  «1»			//
					//	 __________________ ________________________ __________________										//
					//	|      90 м.т.     |        120 м.т.        |      90 м.т.     | количество машинных тактов			//
					//	|    FirstHIGH     |  SendHIGH или SendLOW  |      LastLOW     | название константы					//
					//	|_____(-8м.т.)_____|__(+2м.т.)____(-5м.т.)__|_____(-10м.т.)____| такты использованные в C++			//
						#define NeoPixel_FirstHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 90м.т. - 8м.т. = 82м.т.
						#define NeoPixel_SendHIGH	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 120м.т. + 2м.т. = 122м.т.
						#define NeoPixel_SendLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 120м.т. - 5м.т. = 115м.т.
						#define NeoPixel_LastLOW	"nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop;" // 90м.т. - 10м.т. = 80м.т.
					#else																									//
						#error Библиотека <iarduino_NeoPixel> не поддерживает микроконтроллеры с частотой выше 240 МГц.		//
					#endif																									//
																															//
					//	ВЫПОЛНЯЕМ ПЕРЕДАЧУ ДЛЯ AVR>48МГц, ARM, ESP:															//
						noInterrupts();																						//	Запрещаем исполнение прерываний во время вывода данных
						while(len){																							//	Если есть байты для передачи.
							byte = *arr++;																					//	Получаем значение очередного байта.
							bit  = 8;																						//	Указываем, что в полученном байте есть 8 не переданных битов.
							len  --;																						//	Уменьшаем количество количество ещё не переданных байт.
							while(bit){			 *portOutput=bitHigh;    asm(NeoPixel_FirstHIGH);							//	Устанавливаем 1 и ждём NeoPixel_FirstHIGH
								if( byte&0x80 ){ asm(NeoPixel_SendHIGH); *portOutput=bitLow;    }							//	Для передачи логической  «1» ждём NeoPixel_SendHIGH и устанавливаем 0.
								else           { *portOutput=bitLow;     asm(NeoPixel_SendLOW); }							//	Для передачи логического «0» устанавливаем 0 и ждём NeoPixel_SendLOW.
								asm(NeoPixel_LastLOW);																		//	ждём NeoPixel_LastLOW.
								byte <<= 1;																					//	Сдвигаем все биты байта byte влево.
								bit--;																						//	Уменьшаем количество количество ещё не переданных бит.
							}																								//
						}																									//
						interrupts();																						//	Возобновляем исполнение прерываний (если таковые были)
				#endif																										//
			}																												//
}																															//
																															//
void	iarduino_NeoPixel::setColor(uint16_t n, uint32_t rgb, uint8_t j){													//
			setColor(n, (rgb&0xFF0000)>>16, (rgb&0x00FF00)>>8, (rgb&0x0000FF), j);											//
}																															//